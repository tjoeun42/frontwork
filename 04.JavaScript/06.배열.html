<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>배열</title>
    <style>
        .area {
            border: 1px solid;
            padding: 5px;
            width: 500px;
        }
    </style>
</head>
<body>
    <h1>배열</h1>
    <p>
        - 변수 선언시 별도의 자료형 지정하지 않음<br>
        - 어떤 자료형의 값들이든 모두 하나의 배열 공간에 담을 수 있음<br>
        - 크기의 제약이 없음<br>
        - 존재하지 않는 인덱스를 참조해도 오류나지않음. undefined리턴
    </p>

    <button onclick="arrayTest1();">확인하기</button>
    <div class="area" id="area1"></div>

    <script>
        function arrayTest1() {
            const area1 = document.getElementById('area1');
            const arr = ['더조은', '서울', 50, true, [1,2,3]];

            console.log(arr);
            console.log(arr[4]);
            console.log(arr[4][1]);

            for(let i=0; i<arr.length; i++) {
                area1.innerHTML += `${arr[i]} <br>`;
            }

            area1.innerHTML += '<hr>';

            for(let i=0; i<arr[4].length; i++) {
                area1.innerHTML += `${arr[4][i]} <br>`;
            }
        }
    </script>

    <hr>

    <h3>* 배열의 선언</h3>
    <button onclick="arrayTest2();">확인하기</button>

    <script>
        function arrayTest2() {
            const arr1 = new Array();
            const arr2 = new Array(3);
            const arr3 = [];

            console.log(arr1);
            console.log(arr2);
            console.log(arr3);

            // 배열 값 대입
            arr1[0] = '포도';
            arr1[1] = '사과';
            arr1[9] = '키위';

            console.log(arr1);  // arr1[9]를 넣으면 length는 10

            // 최초 배열의 갯수보다 더 넣어도 됨.
            arr2[0] = "자동차";
            arr2[1] = "기차";
            arr2[2] = "오토바이";
            arr2[9] = "전철";

            console.log(arr2);

            // 배열 선언과 동시에 초기화
            const arr4 = new Array('더조은', '김수연', '홍사부');
            const arr5 = ['java', 'css', 'oracle'];

            console.log(arr4);
            console.log(arr5);
        }
    </script>

    <hr>

    <h3>* 배열 관련 메소드</h3>

    <h4>1) 배열.indexOf(찾고자하는요소) : 배열에서 해당 요소가 있는 index 반환</h4>

    <div class="area" id="area2"></div>
    <button onclick="indexOfTest();">확인하기</button>

    <script>
        function indexOfTest() {
            const area2 = document.getElementById('area2');
            const arr = ['사과', '딸기', '키위', '포도', '파인애플'];
            
            const fruit = prompt('찾는 과일명 입력');

            const index = arr.indexOf(fruit);
            console.log(index);

            area2.innerHTML = `당신이 찾는 과일 ${fruit}는 `;
            if(index >= 0)
                area2.innerHTML += `${index}번 진열대에 있습니다.`;
            else
                area2.innerHTML += `판매하지 않습니다.`;

            // 자바스크립트에서의 두 값이 동일한지 비교하는 연산자
            console.log(1 == 1);
            console.log(1 == '1');   // 동등연산자(==)는 자료형은 상관없이 값이 일치하면 true
            console.log(1 === '1');  // 엄격 동등연산자(===)는 값과 자료형이 같아야 true, 하나라도 다르면 false
        }
    </script>

    <hr>

    <h4>2) 배열.concat(배열, 배열,...) : 배열 여러개를 결합하고자 할 때 사용</h4>
    <p>- 원본 배열에 영향을 끼치지 않는 메소드</p>

    <div class="area" id="area3"></div>
    <button onclick="concatTest();">확인하기</button>

    <script>
        function concatTest() {
            const area3 = document.querySelector('#area3');

            const arr1 = ['사과', '딸기'];
            const arr2 = ['복숭아', '포도', '키위'];

            area3.innerHTML = `arr1 : ${arr1}<br>`;
            area3.innerHTML += `arr2 : ${arr2}<br>`;

            area3.innerHTML += `arr1을 기준으로 배열 합침 : ${arr1.concat(arr2)}<br>`;
            area3.innerHTML += `원본arr1 : ${arr1}<br>`;

            area3.innerHTML += `arr2 기준으로 배열 합침 : ${arr2.concat(arr1, [1,2,3])}<br>`;
        }
    </script>

    <hr>

    <h4>3) 배열.reverse() : 배열에 담긴 값들을 역순으로 바꿔주는 메소드</h4>
    <p>- 원본 배열에 영향을 끼치는 메소드</p>

    <div class="area" id="area4"></div>
    <button onclick="reverseTest();">확인하기</button>

    <script>
        function reverseTest() {
            const area4 = document.getElementById('area4');
            const arr = [1,2,3,4,5];

            area4.innerHTML = `arr : ${arr}<br>`;
            area4.innerHTML += `reverse한 결과 : ${arr.reverse()}<br>`;
            area4.innerHTML += `원본arr : ${arr}<br>`; 
        }
    </script>

    <hr>

    <h4>4) 배열.sort() : 배열안에 담긴 값들을 오름차순으로 정렬해주는 메소드</h4>
    <p>- 원본 배열에 영향을 끼치는 메소드</p>

    <div class="area" id="area5"></div>
    <button onclick="sortTest();">확인하기</button>

    <script>
        function sortTest() {
            const area5 = document.getElementById('area5');
            const name = ['나행복', '이띨띨', '박초롱', '최똘똘', '김똑똑'];

            area5.innerHTML = `name : ${name}<br>`;
            area5.innerHTML += `sort한 결과 : ${name.sort()}<br>`;
            area5.innerHTML += `원본name : ${name}<br>`;

            // 내림차순 => 오름차순 정렬을 한 후 역순으로 뒤집기
            area5.innerHTML += `내림차순 정렬 : ${name.sort().reverse()}`;
        }
    </script>

    <hr>

    <h4>
        5-1) 배열.push(추가할요소) : 배열의 맨 뒤에 요소 추가시키고 배열의 크기 반환<br>
        5-1) 배열.pop() : 배열의 맨 뒤의 요소 제거시키고 제거된 요소 반환
    </h4>

    <div class="area" id="area6"></div>
    <button onclick="pushPopTest();">확인하기</button>

    <script>
        function pushPopTest() {
            const area6 = document.querySelector('#area6');

            const arr = ['서초동', '방배동', '역삼동', '삼성동', '대치동'];
            area6.innerHTML = `arr : ${arr}<br>`;
            area6.innerHTML += `arr에 push후 반환값 : ${arr.push('구로동')}<br>`;
            area6.innerHTML += `arr에 push후 배열 : ${arr}<br>`;
            arr.push('잠실본동');
            area6.innerHTML += `arr에 push후 배열: ${arr}<br>`;

            // 맨 마지막 요소 삭제
            area6.innerHTML += `arr에 pop후 반환값 : ${arr.pop()}<br>`;
            area6.innerHTML += `arr에 pop후 배열 : ${arr}<br>`;
        }
    </script>

    <hr>

    <h4>
        6-1) 배열.unshift(추가할요소) : 배열의 맨 앞에 요소 추가시키고 배열의 크기 반환<br>
        6-1) 배열.shift() : 배열의 맨 앞의 요소 제거시키고 제거된 요소 반환
    </h4>

    <div class="area" id="area7"></div>
    <button onclick="unshiftTest();">확인하기</button>

    <script>
        function unshiftTest() {
            const area7 = document.getElementById('area7');

            const arr = ['야구', '볼링', '테니스', '당구'];
            area7.innerHTML = `arr : ${arr}<br>`;

            // 맨 앞에 요소 추가
            area7.innerHTML += `arr에 unshift후 : ${arr.unshift('탁구')}<br>`;
            area7.innerHTML += `unshift후 배열 : ${arr}<br>`; 

            // 맨 앞에 요소 제거
            area7.innerHTML += `arr에 shift후 : ${arr.shift()}<br>`;
            area7.innerHTML += `shift후 배열 : ${arr}<br>`;
        }
    </script>

    <hr>

    <h4>
        7-1) 배열.slice(시작인덱스, 끝인덱스) : 배열로부터 시작인텍스부터 끝인덱스까지 추출해주는 메소드<br>
        7-1) 배열.splice(시작인덱스, 제거수[, 추가할 값]) : 배열의 요소를 추출하여 제거 및 추가. 제거한 요소 반환
    </h4>

    <div class="area" id="area8"></div>
    <button onclick="sliceTest();">확인하기</button>

    <script>
        function sliceTest() {
            const area8 = document.getElementById('area8');

            const arr = ['java', 'oracle', 'html', 'css', 'javaScript'];
            area8.innerHTML = `arr : ${arr}<br>`;

            // slice : 원본배열에 영향을 끼치지 않는 메소드
            area8.innerHTML += `slice : ${arr.slice(2, 4)}<br>`;
            area8.innerHTML += `원본 arr : ${arr}<br>`;
            area8.innerHTML += `slice : ${arr.slice(3)}<br>`;

            // splice : 원본배열에 영향을 끼치는 메소드
            area8.innerHTML += `splice : ${arr.splice(2, 2)}<br>`;
            area8.innerHTML += `원본 arr : ${arr}<br>`;
            area8.innerHTML += `splice : ${arr.splice(1, 2, 'spring', 'react', 'aws')}<br>`;
            area8.innerHTML += `원본 arr : ${arr}<br>`;
        }
    </script>

    <hr>

    <h4>
        8) 배열.toString() / 배열.join([구분자]) : 배열에 각 인덱스에 담긴 값들을 하나의 '문자열'로 합쳐서 반환
    </h4>

    <div class="area" id="area9"></div>
    <button onclick="joinTest();">확인하기</button>

    <script>
        function joinTest() {
            const area9 = document.getElementById('area9');

            const arr = ['나는', '오늘', '맛있는', '저녁식사였어'];
            area9.innerHTML = `arr : ${arr}<br>`;
            area9.innerHTML += `toString : ${arr.toString()}<br>`;

            area9.innerHTML += `join : ${arr.join()}<br>`;  // 기본 구분자는 컴마(,)임
            area9.innerHTML += `join : ${arr.join(' ')}<br>`;
        }
    </script>

    <hr>

    <h4>9) 반복처리(for문, for ..in문, for ..of문, forEach)</h4>

    <div class="area" id="area10"></div>
    <button onclick="for1();">확인하기</button>

    <script>
        function for1() {
            const area10 = document.querySelector('#area10');
            const arr = ['가', '나', '다'];

            area10.innerHTML += 'for : ';
            for(let i=0; i<arr.length; i++) {
                area10.innerHTML += `${arr[i]}, `;
            }
            area10.innerHTML += '<br>';

            // for of문(자바의 향상된 for문과 동일)
            area10.innerHTML += 'for of : ';
            for(let ch of arr) {
                area10.innerHTML += `${ch}, `;
            }
            area10.innerHTML += '<br>';

            // for in문 : 배열의 인덱스 속성을 가져옴
            area10.innerHTML += 'for in : ';
            for(let i in arr) {
                area10.innerHTML += `${i} -> ${arr[i]}, `;
            }
            area10.innerHTML += '<br>';

            // forEach() : 각 요소별로 전달한 함수(콜백함수)를 실행
            area10.innerHTML += 'forEach : <br>';

            arr.forEach(function(value, index, arr1) {
                area10.innerHTML += `${value} : ${index} : ${arr1}<br>`;
            });
        }
    </script>
</body>
</html>